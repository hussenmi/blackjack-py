The zip folder contains three files. The `README.md` file, the main `blackjack.py` file, and the `test_blackjack.py` file. To run the game, navigate to the folder containing these files from the command line and run `python blackjack.py`. There are no other dependencies that need to be installed. The only libraries the program uses are the `random` module and the `itertools` module, both of which come in with the standard library.

To test my code, I also created unittests using the `unittest` module. This code can be found in `test_blackjack.py`. To run this, go to the same folder in the command line and run `python test_blackjack.py`. Since there is randomness involved in the game, I can't test every aspect of the game using unittests. So for those aspects, I conducted manual tests, which I'll be describing a bit later. In the unittests, I created two classes -- one for the deck and one for the player.

The first class tests functionality associated with the deck. It first initializes the deck object and then checks that its length is equal to 52. It then deals two cards each to both the dealer and the player and makes sure that the deck now has 48 cards remaining. The second class tests functionality associated with the player. For every test, it initializes a deck and a player. The first test checks if the player's hand is accumulating any cards. The second and third tests are checking the ace scoring functionality. The first one tests the value for the hand `['K', '4', 'A']`. For this one, the ace should be scored as a 1 because using it as 11 would bust the hand. The total score should be `10 + 4 + 1 = 15`, and that's what we get. For the second test, I check the value of the hand `['8', 'A', 'A']`. For this one, the first 'A' should be scored as 11, but the second 'A' should be scored as 1 since counting it as 11 would create a bust. The score of this hand should then be `8 + 11 + 1 = 20`, and that's what we get as well.

Since there is randomness involved, manual testing is mainly required in our case to test the functionality of the blackjack game. To perform this, I run my program multiple times with different player interactions and tested the outcome. At some points in the logic, I also tried to manually set the values for the scores of the player and the dealer to test if the logic to handle the different values works. After the dealer initially deals the first two cards, one of the dealer's cards is hidden, but for testing purposes, I made that visible to me so that I can try different inputs and check if the output is what is expected from the program. This technique of printing values in different places allowed me to debug some problems and get to a final product that works properly.

Next, I'll describe how I created the program -- the decisions I made, what I prioritized, and what I would improve if I had more time.

When designing any program, there are a couple of things that are always on my mind. These are the concepts of abstraction, separation of concerns, polymorphism, flexibility, readability, and the choice of inheritance vs composition.

For this specific program, I started off by thinking about the classes I would need. When I broke down the program into smaller components, I decided to have three classes -- one for the deck of cards to be used, one for the players, and another one for the game as a whole, where the logic would be implemented. I chose this structure because it follows the separation of concerns principle I mentioned earlier. Each class would handle only things related to a specific part of the program and none of them are too overwhelmed nor are they implementing functions that don't make sense for them to do so. In the program, the `Deck` class creates a new deck of cards and this is its only responsibility. I gave it its own class because it logically makes sense for it to have its own class. I didn't create a class called `Card` because, for this simple game, we treat the four different types of cards the same way. There is no difference between spades and diamonds for example, so having a `Card` class is not necessary. But if I wanted to adapt it so that we treat spades and diamonds differently, then I can add a `Card` class that would contain the type of the card as an attribute and when creating the deck, I would utilize the `Card` class.

The player also has its own class because of the separation of concerns principle I mentioned earlier. The attributes are `hand` and `score` and these get updated throughout the game. The class also implements different methods that are concerned with the player. These include methods like `hit` and `get_hand_value` that are useful for interacting with the player. In Python, we don't have to worry much about polymorphism because functions can accept different types of inputs and work with them. They can do this because they delegate this task to the object itself. For example, if we use the `len()` function, it doesn't matter if we pass it a string or a list, it'll delegate the task to the object itself by calling `object.__len__()`, therefore, that won't be a problem. In my program, I didn't encounter a situation where I needed to have a single function handle different kinds of inputs, but if that were the case, I'd implement something similar for the different objects to handle the task themselves and when the generic function is called, it'd simply delegate the task to the respective object.

Finally, we have the `Blackjack` class that handles the logic for the game. It starts off by initializing the players and then dealing two cards each. It then asks the player if they want to hit or stand and then follows the logic as described in the guide.

The way the classes are organized also allows for more flexibility. For example, if want to create a new game that utilizes a deck and also players that have the same attributes, we can use them in the new game. If we want to create different versions of blackjack, we could have a template class for blackjack and then, we can create two classes that inherit from the `Blackjack` class and implement functionality that is specific to them. The process I described is called the `template` pattern and is one of the most widely used design patterns.

One major design choice I had to make is to use composition instead of inheritance when dealing with the relationship among classes. For example, in the `Blackjack` class, I utilize objects of the player class for creating the dealer and the player. Using composition here instead of inheritance provides a weak coupling of the classes as it should be since there is no real reason one should inherit from the other because one is not a specialized version of the other.

Finally, if given more time, I would work on making it more realistic by adding more features. I would also create my deck using different suites of cards and have a better version of printing outputs. As discussed above, we could also have different versions of the game and we could create this using the `template` pattern as well.